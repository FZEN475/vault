apiVersion: v1
data:
  backup.sh: |-
    #!/usr/bin/env ash
    BACKUP_DIR="/backup"
    DATA_DIR="/data"
    TIMESTAMP=$(date '+%Y-%m-%d_%H-%M')
    BACKUP_FILE="$BACKUP_DIR/$TIMESTAMP.tar.gz"
    
    # Запечатываем Vault
    if ! vault operator seal; then
      echo "Ошибка: не удалось запечатать Vault" >&2
      exit 1
    fi
    
    if ! tar -czf "$BACKUP_FILE" -C "$DATA_DIR" .; then
      echo "Ошибка: не удалось создать архив $BACKUP_FILE" >&2
      exit 1
    fi
    
    echo "Бэкап создан: $BACKUP_FILE"
    
    find "$BACKUP_DIR" -type f -mtime +182 -print0 | xargs -0 rm -f
    echo "Старые бэкапы удалены"

    vault operator unseal "$VAULT_KEY"
  secret-template.json: |-
    {
      "apiVersion": "v1",
      "kind": "Secret",
      "metadata": {
        "name": "__SECRET_NAME__"
      },
      "type": "Opaque",
      "stringData": {
        "token": "__TOKEN__",
        "key": "__KEY__"
      }
    }
    
  scripts.sh: |-
    function log_info() {
      echo -e "[\\e[1;94mINFO\\e[0m] $*"
    }
    
    function log_warn() {
      echo -e "[\\e[1;93mWARN\\e[0m] $*"
    }
    
    function log_error() {
      echo -e "[\\e[1;91mERROR\\e[0m] $*"
    }
    
    function fail() {
      log_error "$*"
      exit 1
    }
    
    get_secret() {
      attempts=10
      i=1
    
      while [ "$i" -le "$attempts" ]; do
        resp="$(
          curl -s --cacert "$SA_CA" \
          -H "Authorization: Bearer $SA_BEARER" \
          "$KUBE_API/api/v1/namespaces/$NAMESPACE/secrets/$SECRET_NAME"
        )" && {
          echo "$resp"
          return 0
        }
        i=$((i + 1))
        sleep 3
      done
    
      return 1
    }
    
    get_vault_token() {
      : "${SA_DIR:=/run/secrets/kubernetes.io/serviceaccount}"
      : "${SA_TOKEN:=$SA_DIR/token}"        
      : "${SA_CA:=$SA_DIR/ca.crt}"
      : "${NAMESPACE:=$(cat $SA_DIR/namespace 2>/dev/null)}"
      : "${KUBE_HOST:=${KUBERNETES_SERVICE_HOST}}"
      : "${KUBE_PORT:=${KUBERNETES_SERVICE_PORT}}"
      : "${SECRET_NAME:=vault}"

      export VAULT_CACERT="$SA_CA"
      export VAULT_CLIENT_TIMEOUT=300s

      [ -f "$SA_TOKEN" ] || return 1
      [ -z "$NAMESPACE" ] || [ -z "$KUBE_HOST" ] || [ -z "$KUBE_PORT" ] && return 1

      KUBE_API="https://${KUBE_HOST}:${KUBE_PORT}"
      SA_BEARER="$(cat "$SA_TOKEN")"
      
      INIT=$(vault status | awk '$1=="Initialized" {print $2}')
    
      if [ "$INIT" = "true" ]; then
        resp="$(get_secret)" || return 1
        token="$(echo "$resp" | awk -F'"' '/"token"/{print $4}' | base64 -d 2>/dev/null)"
        [ -z "$token" ] && return 1

        echo "$token"
        return 0
      fi
      vault operator init -key-shares=1 -key-threshold=1 > /tmp/init-result.txt || return 1
      sleep 5
      token="$(awk '/Initial Root Token:/ {print $4}' /tmp/init-result.txt)"
      key="$(awk '/Unseal Key 1:/ {print $4}' /tmp/init-result.txt)"
      if [ -z "$token" ] || [ -z "$key" ]; then
        return 1
      fi
      SECRET_JSON=$(sed \
        -e "s|__SECRET_NAME__|$SECRET_NAME|g" \
        -e "s|__TOKEN__|$token|g" \
        -e "s|__KEY__|$key|g" \
        /tmp/init/secret-template.json
      )
      code="$(
        curl -s -o /dev/null -w "%{http_code}" --cacert "$SA_CA" \
          -X POST \
          -H "Authorization: Bearer $SA_BEARER" \
          -H "Content-Type: application/json" \
          -d "$SECRET_JSON" \
          "$KUBE_API/api/v1/namespaces/$NAMESPACE/secrets")"
      if [ "$code" == "201" ]; then
        echo "$token"
        return 0
      fi
      return 1
    }
    unseal_vault() {
      : "${SA_DIR:=/run/secrets/kubernetes.io/serviceaccount}"
      : "${SA_TOKEN:=$SA_DIR/token}"        
      : "${SA_CA:=$SA_DIR/ca.crt}"
      : "${NAMESPACE:=$(cat $SA_DIR/namespace 2>/dev/null)}"
      : "${KUBE_HOST:=${KUBERNETES_SERVICE_HOST}}"
      : "${KUBE_PORT:=${KUBERNETES_SERVICE_PORT}}"
      : "${SECRET_NAME:=vault}"
      sleep 5
      KUBE_API="https://${KUBE_HOST}:${KUBE_PORT}"
      SA_BEARER="$(cat "$SA_TOKEN")"
      set -x
      resp="$(get_secret)" || return 1
      set +x
      key="$(echo "$resp" | awk -F'"' '/"key"/{print $4}' | base64 -d 2>/dev/null)"
      [ -z "$key" ] && return 1
      vault operator unseal "$key"
    }
  
  configure-auth.sh: |-
    function configure_github_auth() {
      vault auth enable github || true
      vault write auth/github/config organization=FZEN475 || true
      vault write auth/github/map/users/Firzen475 value=default || true
    }
    function configure_kubernetes_auth() {
      vault auth enable kubernetes || true
      vault policy write default - <<EOF
    path "default**"              { capabilities = ["read", "list"] }
    path "auth/token/lookup-self" { capabilities = ["read"] }
    EOF
      vault write auth/kubernetes/config \
        kubernetes_host=https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT
    }
    
    
    function configure_etcd_pki() {
      vault secrets enable pki || true
      vault secrets tune -max-lease-ttl=8760h pki || true
      cat /etc/ssl/etcd/ca_etcd.pem /etc/ssl/etcd/ca_etcd-key.pem > /tmp/bundle.pem
      vault write pki/config/ca \
        pem_bundle=@/tmp/bundle.pem || true
      vault write pki/config/urls \
        issuing_certificates="https://vault.secrets.svc:8200/v1/pki/ca" \
        crl_distribution_points="https://vault.secrets.svc:8200/v1/pki/crl" || true
      vault write pki/roles/etcd \
        allowed_domains="etcd.fizn.ru" \
        allow_any_name=true \
        client_flag=true \
        server_flag=false \
        max_ttl="8760h" || true
      vault policy write pki - <<EOF
    path "pki/*"                        { capabilities = ["read", "list"] }
    path "pki/sign/etcd"    { capabilities = ["create", "update"] }
    path "pki/issue/etcd"   { capabilities = ["create"] }
    EOF
      vault write auth/kubernetes/role/issuer \
        bound_service_account_names=issuer \
        bound_service_account_namespaces=secrets \
        policies=pki \
        ttl=20m || true
    }
    
    function create_secret_if_not_exists() {
      mount="$1"
      secret_path="$2"
      shift 2
    
      if vault kv get -mount="$mount" "$secret_path" >/dev/null 2>&1; then
        echo "Секрет $mount/$secret_path уже существует, пропускаем создание."
      else
        echo "Создаем секрет $mount/$secret_path..."
        vault kv put -mount="$mount" "$secret_path" "$@"
      fi
    }
    
    function configure_cert_manager() {
      vault secrets enable -path=secrets kv-v2 || true
      create_secret_if_not_exists secrets \
        "cert-manager/cloudflare-api-secrets" \
        api-token=unset

      vault policy write cert-manager - <<EOF
    path "storage/data/cert-manager/*" { capabilities = ["read", "list"] }
    EOF
      vault write auth/kubernetes/role/cert-manager \
        bound_service_account_names=cert-manager-sa \
        bound_service_account_namespaces=secrets \
        policies=cert-manager \
        ttl=20m || true
    }
    
    function configure_pgsql() { 
      vault secrets enable -path=storage kv-v2 || true
      REPLICATION_PASSWORD="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 8)"
      create_secret_if_not_exists storage \
        "pgsql/pgsql-secrets" \
        postgres-password=unset \
        replication-password="$REPLICATION_PASSWORD"
      vault policy write pgsql - <<EOF
    path "storage/data/pgsql/*" { capabilities = ["read", "list"] }
    EOF
      vault write auth/kubernetes/role/pgsql \
        bound_service_account_names=pgsql-sa \
        bound_service_account_namespaces=storage \
        policies=pgsql \
        ttl=20m || true
    
      vault secrets enable -path=database/data database || true
      PG_PASS=$(vault kv get -field=postgres-password storage/pgsql/pgsql-secrets)
      vault write database/data/config/pgsql \
        plugin_name="postgresql-database-plugin" \
        connection_url="postgresql://{{"{{"}}username{{"}}"}}:{{"{{"}}password{{"}}"}}@postgresql-primary.storage.svc:5432/postgres?sslmode=require" \
        allowed_roles="gitlab, telebot-gpt" \
        username="postgres" \
        password="$PG_PASS" \
        password_authentication="scram-sha-256" || true 
     
    }
    
    function configure_redis() {
      vault secrets enable -path=storage kv-v2 || true
      REDIS_MASTER_PASSWORD="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 8)"
      REDIS_GITLAB_PASSWORD="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 8)"
      REDIS_TELEBOT_GPT_PASSWORD="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 8)"
      create_secret_if_not_exists storage \
        "redis/server" \
        redis-master-password="$REDIS_MASTER_PASSWORD"
      create_secret_if_not_exists storage \
        "redis/gitlab" \
        password="$REDIS_GITLAB_PASSWORD"
      create_secret_if_not_exists storage \
        "redis/telebot-gpt" \
        password="$REDIS_TELEBOT_GPT_PASSWORD"
      vault policy write redis - <<EOF
    path "storage/data/redis/*" { capabilities = ["read", "list"] }
    EOF
      vault write auth/kubernetes/role/redis \
        bound_service_account_names=redis-sa \
        bound_service_account_namespaces=storage \
        policies=redis \
        ttl=20m || true
    }

    function configure_minio() {
      vault secrets enable -path=storage kv-v2 || true
      MINIO_MASTER_PASSWORD="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 8)"
      MINIO_GITLAB_PASSWORD="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 8)"
      MINIO_LOKI_PASSWORD="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 8)"
      create_secret_if_not_exists storage \
        "minio/server" \
        root-user=root \
        root-password="$REDIS_MASTER_PASSWORD"
      create_secret_if_not_exists storage \
        "minio/gitlab" \
        secret-key=gitlab-sa \
        password="$MINIO_GITLAB_PASSWORD"
      create_secret_if_not_exists storage \
        "minio/loki" \
        secret-key=loki-sa \
        password="$MINIO_LOKI_PASSWORD"
      vault policy write minio - <<EOF
    path "storage/data/minio/*" { capabilities = ["read", "list"] }
    EOF
      vault write auth/kubernetes/role/minio \
        bound_service_account_names=minio-sa \
        bound_service_account_namespaces=storage \
        policies=minio \
        ttl=20m || true
    }

    function configure_gitlab() {
      vault secrets enable -path=gitlab kv-v2 || true

      # role
      vault write auth/kubernetes/role/gitlab \
        bound_service_account_names=gitlab-sa \
        bound_service_account_namespaces=gitlab \
        policies=gitlab-pgsql,gitlab-redis,gitlab-minio,gitlab-rails,gitlab-gitaly,gitlab-shell,gitlab-webservice,gitlab-kas,gitlab-registry,gitlab-registry-access,gitlab-pages \
        ttl=20m
    
      # gitlab-pgsql
      vault write database/data/static-roles/gitlab \
        db_name="pgsql" \
        username="gitlab" \
        rotation_statements="ALTER USER {{"{{"}}username{{"}}"}} PASSWORD '{{"{{"}}password{{"}}"}}'" \
        rotation_period="24h" || true
      vault policy write gitlab-pgsql - <<EOF
    path "database/data/static-creds/gitlab"                        { capabilities = ["read", "list"] }
    EOF
      
      # gitlab-redis
      vault policy write gitlab-redis - <<EOF
    path "storage/data/redis/gitlab" { capabilities = ["read"] }
    EOF

      # gitlab-minio
      vault policy write gitlab-minio - <<EOF
    path "storage/data/minio/gitlab" { capabilities = ["read"] }
    EOF

      # gitlab-rails
      SECRET_KEY_BASE="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      OTP_KEY_BASE="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      DB_KEY_BASE="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      ENCRYPTED_SETTINGS_KEY_BASE="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      OPENID_CONNECT_SIGNING_KEY="ssh-keygen -t rsa -b 2048 -f /tmp/id_ssh_rsa -N "" >/dev/null && cat /tmp/id_ssh_rsa | base64 -d 2>/dev/null | sed 's/^/    /' | base64"
      ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      SUGGESTED_REVIEWERS="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      
      create_secret_if_not_exists gitlab \
        "gitlab/rails" \
        secret_key_base="$SECRET_KEY_BASE" \
        otp_key_base="$OTP_KEY_BASE" \
        db_key_base="$DB_KEY_BASE" \
        encrypted_settings_key_base="$ENCRYPTED_SETTINGS_KEY_BASE" \
        openid_connect_signing_key="$OPENID_CONNECT_SIGNING_KEY" \
        active_record_encryption_primary_key="$ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY" \
        active_record_encryption_deterministic_key="$ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY" \
        active_record_encryption_key_derivation_salt="$ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT" \
        suggested_reviewers="$SUGGESTED_REVIEWERS"
      vault policy write gitlab-rails - <<EOF
    path "gitlab/data/gitlab/rails" { capabilities = ["read"] }
    EOF
    
      # gitlab-gitaly
      TOKEN="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 8)"
      TOKEN_SHELL="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 8)"
      create_secret_if_not_exists gitlab \
        "gitlab/gitaly" \
        token="$TOKEN" \
        token_shell="$TOKEN_SHELL"
      vault policy write gitlab-gitaly - <<EOF
    path "gitlab/data/gitlab/gitaly" { capabilities = ["read"] }
    EOF
    
      # gitlab-shell
      SSH_HOST_ED25519_KEY="ssh-keygen -t ed25519 -f /tmp/ssh_host_ed25519_key -N "" -q && cat /tmp/ssh_host_ed25519_key | base64"
      create_secret_if_not_exists gitlab \
        "gitlab/shell" \
        ssh_host_ed25519_key="$SSH_HOST_ED25519_KEY"
      vault policy write gitlab-shell - <<EOF
    path "gitlab/data/gitlab/shell" { capabilities = ["read"] }
    EOF
    
      # gitlab-webservice
      PASSWORD="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      WORKHORSE="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      create_secret_if_not_exists gitlab \
        "gitlab/webservice" \
        password="$PASSWORD" \
        workhorse="$WORKHORSE"
      vault policy write gitlab-webservice - <<EOF
    path "gitlab/data/gitlab/webservice" { capabilities = ["read"] }
    EOF
    
      # gitlab-kas
      KAS_SHARED_SECRET="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      KAS_PRIVATE_API="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      KAS_WEBSOCKET_TOKEN="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      create_secret_if_not_exists gitlab \
        "gitlab/kas" \
        kas_shared_secret="$KAS_SHARED_SECRET" \
        kas_private_api="$KAS_PRIVATE_API" \
        kas_websocket_token="$KAS_WEBSOCKET_TOKEN"
      vault policy write gitlab-kas - <<EOF
    path "gitlab/data/gitlab/kas" { capabilities = ["read"] }
    EOF
    
      # gitlab-registry
      HTTP_SECRET="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 64)"
      NOTIFICATION="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      HOST="gitlab-registry.gitlab.svc"
      create_secret_if_not_exists gitlab \
        "gitlab/registry" \
        httpSecret="$HTTP_SECRET" \
        notification="$NOTIFICATION" \
        host="$HOST"
      vault policy write gitlab-registry - <<EOF
    path "gitlab/data/gitlab/registry" { capabilities = ["read"] }
    EOF
    
      # gitlab-registry-access
      USERNAME="root"
      PASSWORD="TOKEN_FROM_GITLAB"    
      create_secret_if_not_exists gitlab \
        "gitlab/registry-access" \
        username="$USERNAME" \
        password="$PASSWORD"
      vault policy write gitlab-registry-access - <<EOF
    path "gitlab/data/gitlab/registry-access" { capabilities = ["read"] }
    EOF
    
      # gitlab-pages
      SECRET="$(head -c 1024 /dev/urandom | tr 'A-Z' 'a-z' | tr -dc 'a-z0-9' | head -c 32)"
      create_secret_if_not_exists gitlab \
        "gitlab/pages" \
        secret="$SECRET"
      vault policy write gitlab-pages - <<EOF
    path "gitlab/data/gitlab/pages" { capabilities = ["read"] }
    EOF
    
    }

    function configure_gitlab_runner() {
      # role
      vault write auth/kubernetes/role/gitlab-runner-no-tag \
        bound_service_account_names=gitlab-runner-no-tag-sa \
        bound_service_account_namespaces=gitlab \
        policies=gitlab-runner-no-tag \
        ttl=20m
    
      RUNNER_TOKEN="GET_FROM_GITLAB"
      RUNNER_REGISTRATION_TOKEN="AS_RUNNER_TOKEN"
    
      # gitlab-runner-no-tag
      create_secret_if_not_exists gitlab \
        "gitlab-runner/no-tag" \
        runner-token="$RUNNER_TOKEN" \
        runner-registration-token="$RUNNER_REGISTRATION_TOKEN"
      vault policy write gitlab-runner-no-tag - <<EOF
    path "gitlab/data/gitlab-runner/no-tag" { capabilities = ["read"] }
    EOF

      vault write auth/kubernetes/role/gitlab-runner-docker-builder \
        bound_service_account_names=gitlab-runner-docker-builder-sa \
        bound_service_account_namespaces=gitlab \
        policies=gitlab-runner-docker-builder \
        ttl=20m

      # gitlab-runner-docker-builder
      create_secret_if_not_exists gitlab \
        "gitlab-runner/docker-builder" \
        runner-token="$RUNNER_TOKEN" \
        runner-registration-token="$RUNNER_REGISTRATION_TOKEN"
      vault policy write gitlab-runner-docker-builder - <<EOF
    path "gitlab/data/gitlab-runner/docker-builder" { capabilities = ["read"] }
    EOF
    
      vault write auth/kubernetes/role/gitlab-runner-helm \
        bound_service_account_names=gitlab-runner-helm-sa \
        bound_service_account_namespaces=gitlab \
        policies=gitlab-runner-helm \
        ttl=20m
    
      # gitlab-runner-helm
      create_secret_if_not_exists gitlab \
        "gitlab-runner/helm" \
        runner-token="$RUNNER_TOKEN" \
        runner-registration-token="$RUNNER_REGISTRATION_TOKEN"
      vault policy write gitlab-runner-helm - <<EOF
    path "gitlab/data/gitlab-runner/helm" { capabilities = ["read"] }
    EOF
    
      vault write auth/kubernetes/role/gitlab-runner-ansible \
        bound_service_account_names=gitlab-runner-ansible-sa \
        bound_service_account_namespaces=gitlab \
        policies=gitlab-runner-ansible \
        ttl=20m
    
      ID_ED25519="ssh-keygen -t ed25519 -f /tmp/ssh_host_ed25519_key -N "" -q && cat /tmp/ssh_host_ed25519_key | base64"
    
      # gitlab-runner-ansible
      create_secret_if_not_exists gitlab \
        "gitlab-runner/ansible" \
        id_ed25519="$ID_ED25519"
        runner-token="$RUNNER_TOKEN" \
        runner-registration-token="$RUNNER_REGISTRATION_TOKEN"
      vault policy write gitlab-runner-ansible - <<EOF
    path "gitlab/data/gitlab-runner/ansible" { capabilities = ["read"] }
    EOF

    }

    function configure_gitlab_agent() {
      # role
      vault write auth/kubernetes/role/gitlab-agent-infra-gitops \
        bound_service_account_names=gitlab-agent-infra-gitops-sa \
        bound_service_account_namespaces=gitlab \
        policies=gitlab-agent-infra-gitops \
        ttl=20m
    
      TOKEN="GET_FROM_GITLAB"
    
      # gitlab-agent-infra-gitops
      create_secret_if_not_exists gitlab \
        "gitlab-agent/infra-gitops" \
        token="$TOKEN"
      vault policy write gitlab-agent-infra-gitops - <<EOF
    path "gitlab/data/gitlab-agent/infra-gitops" { capabilities = ["read"] }
    EOF

      vault write auth/kubernetes/role/gitlab-agent-library \
        bound_service_account_names=gitlab-agent-library-sa \
        bound_service_account_namespaces=gitlab \
        policies=gitlab-agent-library \
        ttl=20m

      # gitlab-agent-library
      create_secret_if_not_exists gitlab \
        "gitlab-agent/library" \
        token="$TOKEN"
      vault policy write gitlab-agent-library - <<EOF
    path "gitlab/data/gitlab-agent/library" { capabilities = ["read"] }
    EOF

      vault write auth/kubernetes/role/gitlab-agent-dev \
        bound_service_account_names=gitlab-agent-dev-sa \
        bound_service_account_namespaces=gitlab \
        policies=gitlab-agent-dev \
        ttl=20m

      # gitlab-agent-dev
      create_secret_if_not_exists gitlab \
        "gitlab-agent/dev" \
        token="$TOKEN"
      vault policy write gitlab-agent-dev - <<EOF
    path "gitlab/data/gitlab-agent/dev" { capabilities = ["read"] }
    EOF


    }

  vault-init.sh: |-
    #!/bin/ash
    sleep 5
    export VAULT_CACERT='/run/secrets/kubernetes.io/serviceaccount/ca.crt'
    export VAULT_CLIENT_TIMEOUT=300s
    source /tmp/init/scripts.sh
    source /tmp/init/configure-auth.sh
    
    
    log_info "(postStart) Получаем токен Vault..."
    VAULT_TOKEN="$(get_vault_token)"
    rc=$?
    
    if [ "$rc" -ne 0 ] || [ -z "$VAULT_TOKEN" ]; then
      log_error "(postStart) Не удалось получить токен Vault (rc=$rc)"
      log_error "(postStart) При первой установки секрет vault должен отсутствовать."
      log_error "(postStart) Если база существует, секрет vault должен существовать."
      exit 1
    fi
    log_info "(postStart) Токен успешно получен"
    log_info "$VAULT_TOKEN"
    export VAULT_TOKEN=$VAULT_TOKEN
    log_info "(postStart) Попытка разлочить (unseal) Vault..."
    unseal_vault
    rc=$?
    if [ "$rc" -eq 0 ]; then
      log_info "(postStart) Vault успешно разлочен"
    else
      log_error "(postStart) Не удалось разлочить Vault"
      log_error "(postStart) Если база существует, секрет vault должен существовать."
      exit 1
    fi
    log_info "(postStart) Настройка GitHub аутентификации..."
    configure_github_auth
    log_info "(postStart) Включение аутентификации kubernetes"
    configure_kubernetes_auth
    log_info "(postStart) Настройка ключей etcd"
    configure_etcd_pki
    log_info "(postStart) Настройка cert-manager"
    configure_cert_manager
    log_info "(postStart) Настройка pgsql"
    configure_pgsql
    log_info "(postStart) Настройка redis"
    configure_redis
    log_info "(postStart) Настройка minio"
    configure_minio
    log_info "(postStart) Настройка gitlab"
    configure_gitlab
    log_info "(postStart) Настройка gitlab-runner"
    configure_gitlab_runner
    log_info "(postStart) Настройка gitlab-agent"
    configure_gitlab_agent

kind: ConfigMap
metadata:
  name: vault-init
  namespace: secrets
